\s{Basic Logic}\label{2.1-basic-logic}

\ss{True and False}

True or False - in your education, you've been faced with questions where the
answer is \truenm\ or \falsenm? Well, hopefully the answer is \truenm. In math,
we're going to deal with things where we have to decide whether something is
true or not. Moreover, there are going to be a bunch of statements that may or
may not be true, and we'll have to figure out how they relate to each
other. With that in mind, this section has some rules for dealing with truth and
falsehood.

We're going to create two ``values'', and they are called \truenm\ and \falsenm,
respectively. These values are called ``Booleans''. They are named after a
mathematician named George Boole, who studied them rather extensively.

\truenm\ and \falsenm\ are not very interesting on their own. However, when we
have a bunch of things that are either \truenm\ or \falsenm, we can combine them
together in three basic ways:

\begin{itemize}  
\item $A \land B$ should be read as ``$A$ logical-and $B$.'' Both have to be
  \truenm. If one of them is \falsenm, than $A \land B$ is \falsenm. Likewise,
  if $A$ and $B$ are both \truenm, then $A \land B$ is \truenm.

\item $A \lor B$ should be read as ``$A$ logical-or $B$.'' With $A \lor B$, if
  one of $A$ and $B$ is \truenm, then $A \lor B$ is \truenm. It's okay if both
  of them are \truenm.
\item Sometimes we are going to want to say `$A$ is not \truenm'. Instead of
  writing that out each time, I'm instead going to use the symbol $\lnot$. So,
  $\lnot A$ should be read `logical-not $A$'.

\end{itemize}  

\sss{Idris}

Alright, let's pop open an \terminal{idris} shell, and try this out! 

First things first, let's see what ``type'' of thing \truenm\ and \falsenm\ are.

\begin{plainfile}
Idris> :type True
Prelude.Bool.True : Bool
Idris> :type False
Prelude.Bool.False : Bool
\end{plainfile}

Since we are mathematicians, and we are lazy, instead of typing \code{:type
  True}, or \code{:type False}, we can instead type \code{:t True} or \code{:t
  False}.

\begin{plainfile}
Idris> :t True
Prelude.Bool.True : Bool
Idris> :t False
Prelude.Bool.False : Bool
\end{plainfile}

Okay, let's look at $\land$ and $\lor$. As stated above, $A \land B$ is \truenm\
if and only if both $A$ and $B$ are \truenm. $\land$ isn't on many standard
keyboards, so, in most programming languages, $\land$ is replaced with
\code{\&\&}.

\begin{plainfile}
Idris> True && False
False : Bool
Idris> False && True
False : Bool
Idris> False && False
False : Bool
Idris> True && True
True : Bool
\end{plainfile}

\pg{Idris's syntax}

So, before going much further, let's go over some of Idris's weird
notation. \code{Bool} is short for ``Boolean'', as stated above. You should have
already figured that out.

Okay, then what the hell is \code{Prelude.Bool.True}? Why not just \code{True}?
This is actually reasonably complicated. Idris allows for \term{context-based
  overloading}, which basically means that \code{True} could (in theory) mean
something different if you used it in some other context. With that in mind,
Idris feels the need to tell you the \term{fully qualified} name of \code{True}
so you know that \code{True} refers to \code{Prelude.Bool.True}, and not some
other version of \code{True}.

However, when we type something like \code{True \&\& True}, there's enough
context to unambiguously determine which version of \code{True} we are talking
about, so Idris doesn't feel the need to tell us that we're using
\code{Prelude.Bool.True}.

I should note that use of commands preceded by a \code{:} are only to be used in
the shell (the interactive environment). That is, you can't use them in actual
code. You can do most of the \code{:} things in the code through other means,
but the \code{:} commands are limited to the interactive environment.

\pg{Back to Business}

If you saw up there, we had to type out every single instance of which we could
concieve. That's annoying. Let's figure out how to do this on our own. This will
be a good segue to introduce \term{comprehension notation}

\begin{plainfile}
Idris> :let bools = [True, False]
Idris> [(x, y) | x <- bools, y <- bools]
[(True, True),
 (True, False),
 (False, True),
 (False, False)] : List (Bool, Bool)
\end{plainfile}

Okay, what the hell is that? Let's go over this step-by-step

\begin{enumerate}
\item I made the list \code{[True, False]}, and bound it to the name
  \code{bools} using the \code{:let} command.
\item The next line is a \term{list comprehension}. Basically, it's a way of
  making a list of items that satisfy some conditions. The pipe in the middle is
  the key thing. The stuff to the right of the pipe is the conditions, and the
  stuff to the left is what each item looks like. Let's look at that comprehension again.

  \begin{plainfile}
[(x, y) | x <- bools, y <- bools]
  \end{plainfile}

  So, the stuff on the left says that each item will look something like
  \code{(x,y)}. \code{x} and \code{y} are each described on the right side of
  the pipe.

  We'll encounter the $\in$ operator a lot. Basically, when you have a set $A$,
  $x \in A$ means that ``$x$ is an element of $A$''. You should read the $\in$
  as a really crappy E, for ``element of''. \code{<-} is a silly way of trying
  to replicate a $\in$.

  So, on the right-hand side of the pipe, \code{x <- bools} just means
  ``\code{x} is an element of \code{bools}''. Ditto for \code{y}. Note that
  currently we are dealing with lists, which are slightly different than sets.

  So, we have a set of items that look like \code{(x,y)}, where \code{x} and
  \code{y} are both elements of \code{bools}. Indeed, that's the result:
  \begin{plainfile}
[(True, True),
 (True, False),
 (False, True),
 (False, False)] : List (Bool, Bool)
  \end{plainfile}
\end{enumerate}

Alright, so we've listed all pairs of booleans. This is kind of boring. Also,
pairs suck, and are hard to deal with.

We're going to make a \term{truth table}. Basically, we are going to have two
booleans, \code{a} and \code{b}. We are then going to show the result of \code{a
  \&\& b} and \code{a || b}.

We're going to have to move over to a file, call it \terminal{truthtable.idr}:

\begin{plainfile}
module Main

main : IO ()
main = return ()
\end{plainfile}

\code{main = return ()} just says that the function \code{main} does nothing. If
you compile and run this program, nothing interesting is going to happen.

Let's put our list of Booleans in:

\begin{plainfile}
bools : List Bool
bools = [True, False]
\end{plainfile}

It's important to periodically compile your program to make sure there aren't
any errors. Run \code{idris truthtable.idr} (don't include \code{-o
  truthtable}). \

\begin{plainfile}
% idris truthtable.idr
     ____    __     _                                          
    /  _/___/ /____(_)____                                     
    / // __  / ___/ / ___/     Version 0.9.16
  _/ // /_/ / /  / (__  )      http://www.idris-lang.org/      
 /___/\__,_/_/  /_/____/       Type :? for help               

Idris is free software with ABSOLUTELY NO WARRANTY.            
For details type :warranty.
*truthtable>   
\end{plainfile}

We've loaded the file \code{truthtable} into the interactive environment, and we
can examine it interactively.

\begin{plainfile}
*truthtable> bools
[True, False] : List Bool
\end{plainfile}

Cool!

If you've programmed in other languages, you're probably used to dealing mostly
with primitive types (integers, strings, booleans). In a language like Idris,
abstraction is lexically very cheap, and is thus encouraged. We're going to make
a new data type for our row:

\begin{plainfile}
record TruthRow : Bool -> Bool -> Bool -> Bool -> Type where
  MkRow : (a : Bool) -> (b : Bool) -> TruthTable a b (a && b) (a || b)
\end{plainfile}

\ss{Logic}

Mathematicians are too lazy to write things like ``if $A$ is \truenm, then $B$
is \truenm, but if $B$ is \truenm, it doesn't necessarily imply that $A$ is
\truenm.'' So, in math, they use these symbols. I'm also lazy, so I'm going to
use these symbols.

\begin{itemize}
\item $A \implies B$ means that ``if $A$ is \truenm, that means that $B$ must be
  \truenm.'' Note that this \xtb{does not} mean that ``if $B$ is \truenm, then
  $A$ is \truenm.'' Always follow the arrow. $A \implies B$ should be read as
  ``$A$ implies $B$.''

\item $A \impliedby B$ is the same thing as writing $B \implies A$. It's often
  convenient to write $A \impliedby B$ though. $A \impliedby B$ should be read
  ``$A$ is implied by $B$.''

\item $A \iff B$ means that $A \implies B$ and $B \implies A$. You can think of
  $A \iff B$ as meaning ``Saying $A$ is the same thing as saying $B$.'' You
  should read $\iff$ as ``if (and only if).'' ``If (and only if)'' takes a while
  to write, and $\iff$ is often contextually inappropriate. So, I'll sometimes
  use iff (with two `f's) in the place of ``if (and only if)''.

\item $A \notimplies B$ means ``$A$ does not imply $B$.'' \xtb{However}, this
  does not mean, $A$ implies that $B$ is false. It simply means that knowing
  something about $A$ doesn't tell you anything about $B$. Got it? The analog is
  what you'd expect for $A \notimpliedby B$.

\item For any $A$, it is always true that $A \implies A$.

\item For any $A$, it's always true that $A \notimplies \lnot A$

\end{itemize}

Now, I'm very lazy, so I'm going to quit writing ``for every $A$,$B$, and $C$
\ldots'' Instead, I'm going to use the symbol $\forall$. It's an upside-down A,
and it stands for `all'. You should read it as `for all'. So, the above
statement is $\forall A,B,C \ldots$

\begin{itemize}
\item Alright, time for some notation:
  
  \[\forall A,B,C \semicolon \parens{\parens{A \implies B} \land \parens{B \implies C}}
  \implies \parens{A \implies C} \]

  For this reason, we can write things like $A \implies B \implies C$.
  \footnote{A common critique of this practice has to do with
    associativity. That is, many people read $A \implies B \implies C$ as
    $\parens{A \implies B} \implies C$. This translates to ``if $A$ implies $B$,
    then $C$ is \truenm'', which isn't \xti{quite} what we want. The solution is
    to not try to group the operators like that, or use parentheses when you do
    want to group them.}

  You were probably really confused by that last glob of math. Let me read it
  out for you. ``for all $A$, $B$, and $C$, if we know that $A \implies B$, and
  $B \implies C$, then it's true that $A \implies C$.'' Sometimes, I'll write
  the $\forall\ldots$ part after the statement. So, I should have written the
  above as

  \[\parens{\parens{A \implies B} \land \parens{B \implies C}} \implies \parens{A \implies C} \semicolon \forall A,B,C\]

\item If you know that $A \implies B$, then $\lnot A \impliedby \lnot B$.
\end{itemize}

Be careful. If two independent statements happen to be \truenm, it doesn't mean
that one implies the other. Thus, the values $A$, $B$, and $C$ are not
themselves the values \truenm\ and \falsenm, but are instead statements, that,
when evaluated, happen to be \truenm\ or \falsenm.

\begin{ExcList}
  \Exercise{Given $A$, is it always the case that $A \iff A$?}  \Answer{Yes. We
    know that $A \implies A$. Remember, $A \iff A$ is just saying that
    $\parens{A \implies A} \land \parens{A \impliedby A}$. Also recall that
    $A \impliedby B$ is the lazyman's way of writing $B \implies A$. Thus, if
    you know $A \implies A$, then it must be true that $A \impliedby A$, and
    therefore $A \iff A$. }

  \Exercise{Given $A$, is it the case that $A \land A \iff A$?}
  \Answer{Yes. There are two cases we need to deal with here:
    \[
    \left\{
      \begin{array}{rrcl}
        A := \true  \to & \true \land \true   & \iff & \true  \\
        A := \false \to & \false \land \false & \iff & \false \\
      \end{array}
    \right.
    \]
    In both cases, $A \land A \iff A$. Q.E.D. This technique is called ``proof
    by exhaustion''. We named every possible case --- in this case, there were
    only two --- and proved the theorem for each of them.

    You might be wondering what $A := \true \to \ldots$ is. It should be read
    ``let $A$ be \truenm; then, \ldots'' }

  \Exercise{Given $A$ and $B$, is it always the case that
    $A \land B \iff B \land A$?}

  \Answer{Yes. In the previous problem, we showed that $A \land A \iff A$. Thus,
    if $A$ and $B$ are both \truenm, or are both \falsenm, the answer is
    yes. Thus, the only case we need to consider is that in which $A$ is \truenm
    and $B$ is \falsenm.\footnote{You may be wondering why I'm not considering
      the case when $A$ is \falsenm, and $B$ is \truenm. However, as we showed
      earlier, it's the case that if $A \iff B$, then $B \iff A$. Thus if
      $A \land B \iff B \land A$, then $B \land A \iff A \land B$}

    If $\true \land \false \iff \false$, and $\false \land \true \iff \false$.}

  \Exercise{Given $A$, $B$, and $C$, is it always the case that $\parens{A \land B} \land
    C \iff A \land \parens{B \land C}$?}
  \Answer{Yes. }

  \Exercise{Given $A$, is it the case that $A \lor A \iff A$?}
  \Answer{Yes.}

  \Exercise{Given $A$ and $B$, which are both True/False values, is it always
    the case that $A \lor B \iff B \lor A$?}
  \Answer{Yes.}

  \Exercise{Given $A$, $B$, and $C$, is it always the case that $\parens{A \lor B} \lor
    C \iff A \lor \parens{B \lor C}$?}
  \Answer{Yes.}

  \Exercise{Given $A$, $B$, and $C$, what is the result of
    $A \land \parens{B \lor C}$?}
  \Answer{$A \land \parens{B \lor C} \iff \parens{A \land B} \lor \parens{A
      \land C}$}

  \Exercise{What do you think the result of $\lnot\parens{A \land B}$ is?}
  \Answer{I will explain in \cref{2.2-more-logic}, but the answer is

    \[\lnot\parens{A \land B} \iff \parens{\lnot A} \lor \parens{\lnot B}
    \semicolon \forall A,B \]
  }
  \Exercise{What do you think the result of $\lnot\parens{A \lor B}$ is?}
  \Answer{I will explain in \cref{2.2-more-logic}, but the answer is

    \[\lnot\parens{A \lor B} \iff \parens{\lnot A} \land \parens{\lnot B}
    \semicolon \forall A, B \]
  }

  \Exercise{We know, from one of the laws

    \[ \parens{A \implies B} \implies \parens{\lnot A \impliedby \lnot B} \sfall A,B \]

    Is the following true?
    
    \[ \parens{A \implies B} \iff \parens{\lnot A \impliedby \lnot B} \sfall A,B \]

    In the future, I won't put ``is the following true\ldots'', mostly because
    I'm lazy, but it also means that you, the reader, might have a difficult
    time trying to figure out what the point of controversy is. So, in the
    future, I'll instead write:

    \[ \parens{A \implies B} \Qiff \parens{\lnot A \impliedby \lnot B} \sfall A,B \]

    (Notice the ? over $\iff$). Now you know exactly what the question is, and I
    don't have to write as much.

  }
  \Answer{Yes, by just applying the law again. Let's restate the law:

    \[ \parens{A \implies B} \implies \parens{\lnot A \impliedby \lnot B} \sfall A, B\]
    \[ \parens{\lnot A \impliedby \lnot B} \impliedby \parens{A \implies B} \sfall A,B \]
    \[ \parens{\lnot B \implies \lnot A} \impliedby \parens{B \impliedby A} \sfall A,B \]
    \[ \parens{\lnot B \implies \lnot A} \impliedby \parens{B \impliedby A} \sfall A,B \]

    Let $C := \lnot B$, $D := \lnot A$

    \[ \parens{C \implies D} \impliedby \parens{\lnot C \impliedby \lnot D} \sfall C,D \]

    We know, from the law,

    \[ \parens{C \implies D} \implies \parens{\lnot C \impliedby \lnot D} \sfall C,D \]

    Therefore,

    \[ \parens{C \implies D} \iff \parens{\lnot C \impliedby \lnot D} \sfall C,D \]
    \[ \parens{A \implies B} \iff \parens{\lnot A \impliedby \lnot B} \sfall A,B \]

    Q.E.D.
  }
\end{ExcList}
