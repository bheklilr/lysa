\ch{Introduction}

Before I bore you with a bunch of crap you don't care about, let's do some math,
shall we?

There are basically three notions with which you need to be familiar in order to
do anything interesting in math. Those three things are {\it sets}, {\it
  functions}, and {\it proofs}. Unfortunately, to be familiar with one, you have
to be familiar with the other two.\footnote{You'll learn as we go along, when
  math people use a common term like {\it set}, {\it function}, {\it proof},
  {\it group}, {\it continuous} or {\it closed}, they usually mean something
  similar in concept to the colloquial term, but there are some strings
  attached. This is usually the case in the sciences too (e.g. \xti{theory},
  \xti{hypothesis}, \xti{experiment}).}

So, what are each of those things?

\begin{itemize}
\item A \xti{set} is an unordered collection of things. There is also no
  repetition. For instance, $\mset{2, 5}$ is the same as $\mset{5, 2}$ (because
  order doesn't matter). $\mset{2, 5, 5}$ would be the same set, because there's
  no notion of multiplicity.

  I'm going to use some notation for sets later in the book. The explanation for
  the notation doesn't really fit anywhere, so here it is:

  \[ A = \mset{x \mid y } \]

  This should be read as ``$A$ is the set of all values $x$, such that $y$ is
  \truenm. This is called ``set comprehension notation.'' It's not difficult,
  and you'll pick it up as we go along.

\item A \xti{function} is a mathematical construct (well, obviously, else I
  wouldn't be talking about it). Basically, it takes some input, does something
  to it, and spits out some output. If you give the function the same input a
  bunch of times, you should get the same result each time. This concept is
  called ``referential transparency.'' If the function is not referentially
  transparent, then it's not a function. It's something else.

\item A \xti{proof} is basically where you take a bunch of simple facts, called
  \xti{axioms}, and chain them together to make \xti{theorem}s. It's sort of like
  sticking puzzle pieces together to form a picture.

  The puzzle pieces (in this case, the axioms) aren't usually very interesting
  on their own. However, the picture they form (in this case, the theorem) can
  be really cool and enlightening. The proof would be analogous to an explicit
  set of instructions explaining how to put the pieces together.
\end{itemize}

Once you are familiar with each of those concepts, we can do all sorts of cool
stuff.  Throughout the book, we will prove all of the following:

\begin{itemize}
\item If you tap your finger against a bridge at exactly the right frequency,
  the bridge will collapse. (Resonance)
\item The formula used to calculate the interest rate on your mortgage is
  actually just a fancy form of the ratios of angles in a triangle. (Euler's
  formula)
\end{itemize}

\s{How to read the book}

The best way to read this book is to just read it. Don't skip sections, or look
ahead, or anything like that. Just read it straight through. It's also pretty
important that you read the rest of this chapter. I promise it's not too boring.

Do all of the exercises. There aren't that many. However, they are pretty
difficult. The exercises all have solutions, which are on the page after the
exercises.

The exercises are designed to make you think, and widen your perspective on the
topic at hand. They are not designed to be tedious. They are difficult, but the
good kind of difficult.

It would be perfectly okay to just do the exercises (all of them), and then go
back and read the text when you don't understand something.

\s{Introduction (for real this time)}

This is a math book. Well, duh. Why did I write it?

Most math (and science) books nowadays seem to value keeping an academic tone
over ensuring that the reader understands the material, and --- more importantly
--- enjoys reading the book.

I take the opposite approach. I want to create a book that is fun to read and
easy to understand, while eschewing the practice of making myself look good.

The inspiration for this book is \href{http://learnyouahaskell.com/}{{\it Learn
    You a Haskell for Great Good!}, by Miran Lipovaƒça}. Haskell is a programming
language, and LYAH is a great book for learning Haskell. If you are interested
in a print copy of LYAH, see \cite{lyah}.

There is also an incomplete and unofficial
\link{https://github.com/gazay/lysa}{Russian translation}, courtesy of Alexey
Gaziev.

\s{The community}

Despite the fact that I used ``I'' in the first part of the book, LYSA is
actually a community project, and many people participate in the writing of this
book.

If you want to talk to us, or to other math people, come see us in {\tt \#lysa}
on Freenode. If you don't know what IRC is, or you don't have a client set up,
you can connect through
\link{http://webchat.freenode.net/?channels=lysa}{Freenode's webchat}.

If you have any questions about LYSA (or math), feel free to ask in the IRC
channel ({\tt \#lysa} on FreeNode in case you forgot).

If you want to submit a correction, or have some issue, or want to add some
content, really anything having to do with the content of the book, you can
visit \link{https://gitlab.com/lysa/lysa}{our GitLab page}. We also have a
\link{http://learnyou.org}{woefully incomplete website} and a
\link{https://lysa.reddit.com/}{community on Reddit}.

\s{Idris}\label{intro-idris}

In this book, I cover a lot of hard stuff.\footnote{This isn't actually
  true. Math isn't hard, stupid!} Sometimes, it's useful to program your way
through a problem. Every programmer will tell you that programming teaches a
manner of thinking.

Many programmers will cite Steve Jobs\footnote{For you youngsters, Steve Jobs is
  the former CEO of Apple. He's dead now.} famous quote, regarding the use of
programming in his job,

\begin{iquote}
  [sic] \ldots much more importantly, it had nothing to do with using [the
  programs we wrote] for anything practical. It had to do with using them to be
  a mirror of your thought process; to actually learn how to think. I think
  everybody in this country should learn how to program a computer --- should
  learn a computer language --- because it teaches you how to think.
\end{iquote}

\nocite{jobs-programming}

That first sentence or two is actually a pretty good description of mathematics
(and programming). Both are incredibly useful, and have endless practical
applications. That's not the point, though. The whole usefulness thing is a side
gig. It's about learning how to think, and having a rigorous language through
which to express your thoughts. Furthermore, the rigor of the language helps you
build upon your current thoughts to find out even cooler things. That's what
math is about.

Programming and math go hand-in-hand. Programmers and mathematicians will attest
to this; I certainly can. For that reason, throughout this book, there will be
coding exercises in the programming language Idris. Idris is an interesting
programming language for many reasons. The chief of which is that it can be used
to prove things mathematically. Most programming languages can't do this. Idris
can, which is why it is special.\footnote{There are other programming languages
  that can prove things, namely Coq and Agda. However, I'm most familiar with
  Idris, and Idris is probably the most useful, so I'm using Idris. Deal with
  it.}


\ss{Installing Idris}

This is something that is actually rather difficult to summarize, because it
varies from operating system to operating system. I will put down the
instructions for the operating systems I use. If you come upon this and don't
see your operating system, please report this on
\link{https://gitlab.com/lysa/lysa/issues/new}{the issue tracker}. Better yet,
you could add the instructions yourself, and ask me to merge your changes.

\sss{Linux}

\pg{Arch}

You need the Haskell platform and the GNU Multiple-Precision (GMP) library.

\begin{shellsession}
  # pacman -S ghc cabal-install gmp
  % \cabal update
  % \cabal install -j cabal-install
\end{shellsession}

At this point, you'll want to add \terminal{\textasciitilde/.cabal/bin} to your
\terminal{\$PATH} variable.

\begin{shellsession}
  % cabal install -j alex happy haddock hscolour idris
\end{shellsession}

\xtv{alex} and \xtv{happy} are dependencies for a number of Haskell
packages. However, due to a
\link{https://github.com/haskell/cabal/issues/220}{long-standing bug in
  \xtv{cabal}}, they don't get pulled in when packages depend on them.

If the installation doesn't work, please report the bug to
\link{https://github.com/idris-lang/Idris-dev/issues/new}{the Idris people}.

\pg{Gentoo}

You will need the Haskell platform, along with the GNU Multiple Precision (GMP)
library. As of 5 January 2015, the Haskell platform is only available on
\code{\tilde ARCH}, where \code{ARCH} is your processor architecture
(e.g. \code{amd64}, \code{x86}). If you use \code{ARCH}, you can enable these by
adding the following to \filepath{/etc/portage/package.keywords}:\footnote{If
  you already use \code{\tilde ARCH}, you can ignore this}

\begin{plainfile}
dev-lang/ghc
dev-haskell/cabal-install
\end{plainfile}

Regardless of your \code{ACCEPT\_KEYWORDS} variable, you should add the
following to \filepath{/etc/portage/package.use}:

\begin{plainfile}
dev-lang/ghc binary
\end{plainfile}

Otherwise, you have to compile GHC (the Haskell compiler) from scratch, and that
takes forever.

Once you have that all out of the way, you'll want to run the following command as root:

\begin{shellsession}
# emerge -jav dev-lang/ghc dev-haskell/cabal-install
\end{shellsession}

\xtb{Warning}: \terminal{-j} will make the installation a lot faster, but is
more resource-intensive. If your power usage is precious, omit it (i.e. use
\terminal{-av} instead).

Once GHC and cabal-install are installed, you'll want to run the following as a
normal user:

\begin{shellsession}
% cabal update
% cabal install alex happy haddock hscolour
% cabal install idris
\end{shellsession}

You can then get at the Idris shell by running \terminal{idris}.

\s{Target audience}

The explanation of why programming is useful is a good segue into discussing the
target audience.

When I was first writing the book, I wrote it in an effort to strengthen my own
understanding. So, the target audience was me. The very first versions of this
book were about a abstractish branch of math called commutative algebra. Later
on, it seemed more fitting to abstractly go over the basics of math. That's what
the current version of the book does.

That doesn't answer the question: who is the target audience? Well, people who
want to learn basic and intermediate algebra, and to learn why it's so
interesting.

% I am of the opinion that most math textbooks are written the ``wrong way'',
% and this is my attempt to write it the ``right way''.  Most books value
% practical applications over the math itself. I think the math is much more
% interesting than its applications, especially when you approach it the right
% way. I use much more abstraction than most books.

Most books treat math as a tool you can use for calculations. I treat math as a
language you can use to express your ideas. That's the core difference.  This
book will hopefully give you an interest in math itself, rather than just a
cursory knowledge of it.

With that in mind, my book is going to approach the topics much differently than
other books on the same topic. I rely very much on abstraction and intuition.

\s{Licensing}

This book is libre\footnote{\xti{Libre} is a French word, which, translated to
  English, means \xti{free} in the sense of liberty, as opposed to price. Think
  \xti{free speech}, not \xti{free beer}.}. You can copy this book and give it
to your friend. You can even print it out and sell it to people.\footnote{There
  are some restrictions though, see \cref{gfdl}.}  If, for instance, you are a
schoolteacher and want to use this for your class, you are free to edit it to
your liking and give the modified copy to your students. The only string I
attach is, you have to allow anyone to whom you give the book do the same thing
(i.e. they have to be free to copy/modify/change your version). The details of
this can be found in \cref{gfdl}.

LYSA is licensed under the GNU Free Documentation License. \Cref{gfdl} contains
the license. Please read the license; it's actually pretty comprehensible.

The source for this book can be downloaded at
\url{https://gitlab.com/lysa/lysa/repository/archive.tar.gz}. If you are looking
to contribute, it's probably best to clone the git repository. You can clone the
git repository by running \terminal{git clone https://gitlab.com/lysa/lysa.git}
in a terminal.
