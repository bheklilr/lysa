\ch{Introduction}

Before I bore you with a bunch of crap you don't care about, let's do some math,
shall we?

There are basically three notions with which you need to be familiar in order to
do anything interesting in math. Those three things are {\it sets}, {\it
  functions}, and {\it proofs}. Unfortunately, to be familiar with one, you have
to be familiar with the other two.\footnote{You'll learn as we go along, when
  math people use a common term like {\it set}, {\it function}, {\it proof},
  {\it group}, {\it continuous} or {\it closed}, they usually mean something
  similar in concept to the colloquial term, but there are some strings
  attached. This is usually the case in the sciences too (e.g. \xti{theory},
  \xti{hypothesis}, \xti{experiment}).}

So, what are each of those things?

\begin{itemize}
\item A \xti{set} is an unordered collection of things. There is also no
  repetition. For instance, $\mset{2, 5}$ is the same as $\mset{5, 2}$ (because
  order doesn't matter). $\mset{2, 5, 5}$ would be the same set, because there's
  no notion of multiplicity.

  I'm going to use some notation for sets later in the book. The explanation for
  the notation doesn't really fit anywhere, so here it is:

  \[ A = \mset{x \mid y } \]

  This should be read as ``$A$ is the set of all values $x$, such that $y$ is
  \truenm. This is called ``set comprehension notation.'' It's not difficult,
  and you'll pick it up as we go along.

\item A \xti{function} is a mathematical construct (well, obviously, else I
  wouldn't be talking about it). Basically, it takes some input, does something
  to it, and spits out some output. If you give the function the same input a
  bunch of times, you should get the same result each time. This concept is
  called ``referential transparency.'' If the function is not referentially
  transparent, then it's not a function. It's something else.

\item A \xti{proof} is basically where you take a bunch of simple facts, called
  \xti{axioms}, and chain them together to make \xti{theorem}s. It's sort of like
  sticking puzzle pieces together to form a picture.

  The puzzle pieces (in this case, the axioms) aren't usually very interesting
  on their own. However, the picture they form (in this case, the theorem) can
  be really cool and enlightening. The proof would be analogous to an explicit
  set of instructions explaining how to put the pieces together.
\end{itemize}

Once you are familiar with each of those concepts, we can do all sorts of cool
stuff.  Throughout the book, we will prove all of the following:

\begin{itemize}
\item If you tap your finger against a bridge at exactly the right frequency,
  the bridge will collapse. (Resonance)
\item The formula used to calculate the interest rate on your mortgage is
  actually just a fancy form of the ratios of angles in a triangle. (Euler's
  formula)
\end{itemize}

\s{How to read the book}

The best way to read this book is to just read it. Don't skip sections, or look
ahead, or anything like that. Just read it straight through. It's also pretty
important that you read the rest of this chapter. I promise it's not too boring.

Do all of the exercises. There aren't that many. However, they are pretty
difficult. The exercises all have solutions, which are on the page after the
exercises.

The exercises are designed to make you think, and widen your perspective on the
topic at hand. They are not designed to be tedious. They are difficult, but the
good kind of difficult.

It would be perfectly okay to just do the exercises (all of them), and then go
back and read the text when you don't understand something.

\s{Introduction (for real this time)}

This is a math book. Well, duh. Why did I write it?

Most math (and science) books nowadays seem to value keeping an academic tone
over ensuring that the reader understands the material, and --- more importantly
--- enjoys reading the book.

I take the opposite approach. I want to create a book that is fun to read and
easy to understand, while eschewing the practice of making myself look good.

The inspiration for this book is \href{http://learnyouahaskell.com/}{{\it Learn
    You a Haskell for Great Good!}, by Miran Lipovaƒça}. Haskell is a programming
language, and LYAH is a great book for learning Haskell. If you are interested
in a print copy of LYAH, see \cite{lyah}.

There is also an incomplete and unofficial
\link{https://github.com/gazay/lysa}{Russian translation}, courtesy of Alexey
Gaziev.

\s{The community}

Despite the fact that I used ``I'' in the first part of the book, LYSA is
actually a community project, and many people participate in the writing of this
book.

If you want to talk to us, or to other math people, come see us in {\tt \#lysa}
on Freenode. If you don't know what IRC is, or you don't have a client set up,
you can connect through
\link{http://webchat.freenode.net/?channels=lysa}{Freenode's webchat}.

If you have any questions about LYSA (or math), feel free to ask in the IRC
channel ({\tt \#lysa} on FreeNode in case you forgot).

If you want to submit a correction, or have some issue, or want to add some
content, really anything having to do with the content of the book, you can
visit \link{https://gitlab.com/lysa/lysa}{our GitLab page}. We also have a
\link{http://learnyou.org}{woefully incomplete website} and a
\link{https://lysa.reddit.com/}{community on Reddit}.

\s{Idris}\label{intro-idris}

In this book, I cover a lot of hard stuff.\footnote{This isn't actually
  true. Math isn't hard, stupid!} Sometimes, it's useful to program your way
through a problem. Every programmer will tell you that programming teaches a
manner of thinking.

Many programmers will cite Steve Jobs\footnote{For you youngsters, Steve Jobs is
  the former CEO of Apple. He's dead now.} famous quote, regarding the use of
programming in his job,

\begin{iquote}
  [sic] \ldots much more importantly, it had nothing to do with using [the
  programs we wrote] for anything practical. It had to do with using them to be
  a mirror of your thought process; to actually learn how to think. I think
  everybody in this country should learn how to program a computer --- should
  learn a computer language --- because it teaches you how to think.
\end{iquote}

\nocite{jobs-programming}

That first sentence or two is actually a pretty good description of mathematics
(and programming). Both are incredibly useful, and have endless practical
applications. That's not the point, though. The whole usefulness thing is a side
gig. It's about learning how to think, and having a rigorous language through
which to express your thoughts. Furthermore, the rigor of the language helps you
build upon your current thoughts to find out even cooler things. That's what
math is about.

Programming and math go hand-in-hand. Programmers and mathematicians will attest
to this; I certainly can. For that reason, throughout this book, there will be
coding exercises in the programming language Idris. Idris is an interesting
programming language for many reasons. The chief of which is that it can be used
to prove things mathematically. Most programming languages can't do this. Idris
can, which is why it is special.\footnote{There are other programming languages
  that can prove things, namely Coq and Agda. However, I'm most familiar with
  Idris, and Idris is probably the most useful, so I'm using Idris. Deal with
  it.}


\ss{Installing Idris}

This is something that is actually rather difficult to summarize, because it
varies from operating system to operating system. I will put down the
instructions for the operating systems I use. If you come upon this and don't
see your operating system, please report this on
\link{https://gitlab.com/lysa/lysa/issues/new}{the issue tracker}. Better yet,
you could add the instructions yourself, and ask me to merge your changes.

\sss{Linux}

\pg{Arch}

You need the Haskell platform and the GNU Multiple-Precision (GMP) library.

\begin{shellsession}
  # pacman -S ghc cabal-install gmp
  % \cabal update
  % \cabal install -j cabal-install
\end{shellsession}

At this point, you'll want to add \terminal{\textasciitilde/.cabal/bin} to your
\terminal{\$PATH} variable.

\begin{shellsession}
  % cabal install -j alex happy haddock hscolour idris
\end{shellsession}

\xtv{alex} and \xtv{happy} are dependencies for a number of Haskell
packages. However, due to a
\link{https://github.com/haskell/cabal/issues/220}{long-standing bug in
  \xtv{cabal}}, they don't get pulled in when packages depend on them.

If the installation doesn't work, please report the bug to
\link{https://github.com/idris-lang/Idris-dev/issues/new}{the Idris people}.

\pg{Gentoo}

You will need the Haskell platform, along with the GNU Multiple Precision (GMP)
library. As of 5 January 2015, the Haskell platform is only available on
\code{\tilde ARCH}, where \code{ARCH} is your processor architecture
(e.g. \code{amd64}, \code{x86}). If you use \code{ARCH}, you can enable these by
adding the following to \filepath{/etc/portage/package.keywords}:\footnote{If
  you already use \code{\tilde ARCH}, you can ignore this}

\begin{plainfile}
dev-lang/ghc
dev-haskell/cabal-install
\end{plainfile}

Regardless of your \code{ACCEPT\_KEYWORDS} variable, you should add the
following to \filepath{/etc/portage/package.use}:

\begin{plainfile}
dev-lang/ghc binary
\end{plainfile}

Otherwise, you have to compile GHC (the Haskell compiler) from scratch, and that
takes forever.

Once you have that all out of the way, you'll want to run the following command as root:

\begin{shellsession}
# emerge -jav dev-lang/ghc dev-haskell/cabal-install
\end{shellsession}

\xtb{Warning}: \terminal{-j} will make the installation a lot faster, but is
more resource-intensive. If your power usage is precious, omit it (i.e. use
\terminal{-av} instead).

Once GHC and cabal-install are installed, you'll want to run the following as a
normal user:

\begin{shellsession}
% cabal update
% cabal install alex happy haddock hscolour
% cabal install idris
\end{shellsession}

You can then get at the Idris shell by running \terminal{idris}.

\ss{Install a text editor}

In order to edit Idris code, you need a plain-text editor (as opposed to a word
processor).

Some popular plain-text editors are:

\begin{enumerate}
\item \link{https://wiki.gnome.org/Apps/Gedit}{Gedit} - very easy to use. I
  recommend either Gedit or Kate for beginners.
\item \link{http://kate-editor.org/get-it/}{Kate} - marginally harder than
  Gedit, but it has more features.

  Linux/BSD users: If you are not a KDE user, then don't use Kate. It brings in
  a ton of KDE dependencies. Here's the result of trying to install it on my
  machine:

\begin{plainfile}
% sudo pacman -S kate
[sudo] password for pete: 
resolving dependencies...
:: There are 2 providers available for phonon-qt5-backend:
:: Repository extra
   1) phonon-qt5-gstreamer  2) phonon-qt5-vlc

Enter a number (default=1): 2
looking for conflicting packages...

Packages (54) attica-qt5-5.6.0-1  gamin-0.1.10-8  karchive-5.6.0-1  kauth-5.6.0-1  kbookmarks-5.6.0-1
              kcodecs-5.6.0-1  kcompletion-5.6.0-1  kconfig-5.6.0-1  kconfigwidgets-5.6.0-1
              kcoreaddons-5.6.0-1  kcrash-5.6.0-2  kdbusaddons-5.6.0-1  kded-5.6.0-1  kglobalaccel-5.6.0-1
              kguiaddons-5.6.0-1  ki18n-5.6.0-1  kiconthemes-5.6.0-1  kinit-5.6.0-1  kio-5.6.0-1
              kitemmodels-5.6.0-1  kitemviews-5.6.0-1  kjobwidgets-5.6.0-1  knewstuff-5.6.0-1
              knotifications-5.6.0-1  kparts-5.6.0-1  kservice-5.6.0-1  ktexteditor-5.6.0-1
              ktextwidgets-5.6.0-1  kwallet-5.6.0-1  kwidgetsaddons-5.6.0-1  kwindowsystem-5.6.0-3
              kxmlgui-5.6.0-1  libdbusmenu-qt5-0.9.3+14.10.20140619-1  libgit2-1:0.21.5-1
              libimobiledevice-1.1.7-1  libplist-1.11-1  libusbmuxd-1.0.9-1  libxkbcommon-x11-0.5.0-1
              media-player-info-19-1  phonon-qt5-4.8.3-1  phonon-qt5-vlc-0.8.2-1  polkit-qt5-0.112-2
              qt5-base-5.4.0-3  qt5-declarative-5.4.0-3  qt5-script-5.4.0-3  qt5-svg-5.4.0-3
              qt5-x11extras-5.4.0-3  qt5-xmlpatterns-5.4.0-3  qtchooser-48-1  solid-5.6.0-1  sonnet-5.6.0-1
              threadweaver-5.6.0-1  upower-0.99.2-1  kate-14.12.2-2

Total Download Size:    33.42 MiB
Total Installed Size:  178.32 MiB

:: Proceed with installation? [Y/n] n

\end{plainfile}

\item \link{http://www.vim.org/}{Vim} - It has a sharp, but not steep learning
  curve.
\item \link{https://www.gnu.org/software/emacs/}{GNU Emacs} has an absolutely
  insane learning curve, but is a wonderful editor once you spend 3 years
  learning how to use it.
\end{enumerate}

\ss{Hello World in Idris}

Pretty much every programmer in the world is familiar with the ``Hello, World!''
program. It's a program that exists in every language that just prints out
\code{hello, world}.\footnote{Prints it in the terminal, not on a
  printer. Seriously, who uses paper these days?}

Access the Idris shell by running \code{idris} in a terminal. Here's what mine
looks like:

\begin{plainfile}
% idris
     ____    __     _                                          
    /  _/___/ /____(_)____                                     
    / // __  / ___/ / ___/     Version 0.9.16-git:fca8309
  _/ // /_/ / /  / (__  )      http://www.idris-lang.org/      
 /___/\__,_/_/  /_/____/       Type :? for help               

Idris is free software with ABSOLUTELY NO WARRANTY.            
For details type :warranty.
Idris> 
\end{plainfile}

Note that the \code{\%} is there to indicate that the rest of the line should
typed in a terminal. You shouldn't type the \code{\%}.

There will be a flashing cursor after \code{Idris>}. That's where you type
stuff.\footnote{Note that, during the writing of this book, I've encountered a
  number of bugs in Idris. Trying to fix these bugs requires that I use the same
  version of Idris as the Idris developers, hence my using version
  \code{0.9.16-git:fca8309}. Your version will probably be different.} Here's
hello, world!

\begin{plainfile}
Idris> "hello, world"
"hello, world" : String
\end{plainfile}

That was pretty simple.  Note that you only have to type the thing following
\code{Idris> }, then hit \code{Return}. You shouldn't type \code{Idris> } The
stuff below it is what \terminal{idris} prints. By the way, it's incredibly
important that you type this stuff out yourself, rather than just reading it (or
copying \& pasting).

If things are preceded by \code{Idris>}, that means that it's run in the
interactive environment.\footnote{In case you forgot, the way you access the
  interactive environment is to run \terminal{idris} in a terminal.} If you see
a bunch of Idris code, without \code{Idris>} in front of each line, that means
you should put the code in a file.

Speaking of files, let's make an actual program that you can run on the command
line. Write this in an editor, and save it to a file called
\code{helloworld.idr}:

\lstinputlisting{helloworld.idr}

The computer can't understand the code; the code exists for the benefit of
humans. With that in mind, we need to turn the code into binary language, which
the computer can understand. Doing this by hand would be a nightmare. Luckily,
we have a program to do it for us. To compile the program we wrote, run
\terminal{idris helloworld.idr -o helloworld}. To run it, run
\terminal{./helloworld}.

\begin{shellsession}
% idris helloworld.idr -o helloworld
% ./helloworld
hello, world
\end{shellsession}

\s{Target audience}

The explanation of why programming is useful is a good segue into discussing the
target audience.

When I was first writing the book, I wrote it in an effort to strengthen my own
understanding. So, the target audience was me. The very first versions of this
book were about a abstractish branch of math called commutative algebra. Later
on, it seemed more fitting to abstractly go over the basics of math. That's what
the current version of the book does.

That doesn't answer the question: who is the target audience? Well, people who
want to learn basic and intermediate algebra, and to learn why it's so
interesting.

% I am of the opinion that most math textbooks are written the ``wrong way'',
% and this is my attempt to write it the ``right way''.  Most books value
% practical applications over the math itself. I think the math is much more
% interesting than its applications, especially when you approach it the right
% way. I use much more abstraction than most books.

Most books treat math as a tool you can use for calculations. I treat math as a
language you can use to express your ideas. That's the core difference.  This
book will hopefully give you an interest in math itself, rather than just a
cursory knowledge of it.

With that in mind, my book is going to approach the topics much differently than
other books on the same topic. I rely very much on abstraction and intuition.

\s{Licensing}

This book is libre\footnote{\xti{Libre} is a French word, which, translated to
  English, means \xti{free} in the sense of liberty, as opposed to price. Think
  \xti{free speech}, not \xti{free beer}.}. You can copy this book and give it
to your friend. You can even print it out and sell it to people.\footnote{There
  are some restrictions though, see \cref{gfdl}.}  If, for instance, you are a
schoolteacher and want to use this for your class, you are free to edit it to
your liking and give the modified copy to your students. The only string I
attach is, you have to allow anyone to whom you give the book do the same thing
(i.e. they have to be free to copy/modify/change your version). The details of
this can be found in \cref{gfdl}.

LYSA is licensed under the GNU Free Documentation License. \Cref{gfdl} contains
the license. Please read the license; it's actually pretty comprehensible.

The source for this book can be downloaded at
\url{https://gitlab.com/lysa/lysa/repository/archive.tar.gz}. If you are looking
to contribute, it's probably best to clone the git repository. You can clone the
git repository by running \terminal{git clone https://gitlab.com/lysa/lysa.git}
in a terminal.

\s{Conventions used throughout}

You don't actually have to read this section, but it would be useful.

\begin{enumerate}
\item \code{Things in monospace} are either code snippets or commands to be run
  in a terminal. I have separate stylings for \terminal{terminal commands} and
  \code{inline code snippets}. That said, they are separate but equal, at least
  for the time being.
\item The \S\ symbol refers to a section. So \S\ 3.2 means ``chapter 3, section
  2''.
\item Even though most of the writers are American, I still use the British
  convention of putting periods after quotation marks: ``like this''. The
  British convention is less ambiguous. If you see the American convention
  anywhere in this book, please report it.
\item I will often recommend software. However, I will not recommend any
  non-libre software, or any software that costs money.
\item ``I'' refers to me. ``We'' refers to both me and you, the reader. ``You''
  refers to, you guessed it, the reader. It's the convention in academia to use
  the so-called ``royal we'', such as ``we subtract 2 from both sides of the
  equation to obtain the result \dots''.

  Sometimes, we will accidentally use the royal we, out of habit. God dammit, I
  just did it there. See? It's very difficult to avoid. Like any of the other
  conventions herein, if you see it broken, please report the error to the
  authors. You can use the \bugtracker, or, if you don't want to make a (free
  and libre) GitLab account, you can \emailme.
\item Oh yeah, sometimes I'll use \code{monospace} in things like URLs or emails
  for the sake of disambiguity.
\item Most of the authors use some version of Linux. Hence, when there are
  instructions for computer things (such as installing Idris), I'll write
  instructions for Linux, because that's what I know. There are two solutions
  here:

  \begin{enumerate}
  \item You could try out Linux (it's gratis, and it's easy).
  \item If you know how to do the thing on your OS, and there aren't
    instructions for your OS, you could write up instructions and add them to
    the book. If you don't know how to do that, you could bring it up in the
    \bugtracker\ or \emailme.
  \end{enumerate}

\item If you see some number as a superscript in the middle of text: like
  this\footnote{Hey, you found me!}, then the number refers to a footnote. If
  the superscript number is in the middle of math, it's probably just math.

\item If there's some number in brackets, like this: \cite{lyah}, then it's a
  citation. If you're reading this as a PDF, you can actually click on the
  number, and your PDF reader will take you to the relevant bibliography
  entry. Go ahead, check it out! I'll wait. You can do the same thing for
  footnotes and URLs.\footnote{Well, clicking the URL will open up your web browser, but
  you get the point}
\end{enumerate}
