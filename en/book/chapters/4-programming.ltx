\ch{Programming}

You probably thought I was just being mean when I made you install Idris at the
beginning of the book. Well, I wasn't. Unfortunately, the three preceding
chapters were needed to get here. We're going to program our way through the
last few chapters!

Alright, let's pop open an \terminal{idris} shell, and try this out! 

First things first, let's see what ``type'' of thing \truenm\ and \falsenm\ are.

\begin{plainfile}
Idris> :type True
Prelude.Bool.True : Bool
Idris> :type False
Prelude.Bool.False : Bool
\end{plainfile}

Since we are mathematicians, and we are lazy, instead of typing \code{:type
  True}, or \code{:type False}, we can instead type \code{:t True} or \code{:t
  False}.

\begin{plainfile}
Idris> :t True
Prelude.Bool.True : Bool
Idris> :t False
Prelude.Bool.False : Bool
\end{plainfile}

Okay, let's look at $\land$ and $\lor$. As stated above, $A \land B$ is \truenm\
if and only if both $A$ and $B$ are \truenm. $\land$ isn't on many standard
keyboards, so, in most programming languages, $\land$ is replaced with
\code{\&\&}.

\begin{plainfile}
Idris> True && False
False : Bool
Idris> False && True
False : Bool
Idris> False && False
False : Bool
Idris> True && True
True : Bool
\end{plainfile}

\pg{Idris's syntax}

So, before going much further, let's go over some of Idris's weird
notation. \code{Bool} is short for ``Boolean'', as stated above. You should have
already figured that out.

Okay, then what the hell is \code{Prelude.Bool.True}? Why not just \code{True}?
This is actually reasonably complicated. Idris allows for \term{context-based
  overloading}, which basically means that \code{True} could (in theory) mean
something different if you used it in some other context. With that in mind,
Idris feels the need to tell you the \term{fully qualified} name of \code{True}
so you know that \code{True} refers to \code{Prelude.Bool.True}, and not some
other version of \code{True}.

However, when we type something like \code{True \&\& True}, there's enough
context to unambiguously determine which version of \code{True} we are talking
about, so Idris doesn't feel the need to tell us that we're using
\code{Prelude.Bool.True}.

I should note that use of commands preceded by a \code{:} are only to be used in
the shell (the interactive environment). That is, you can't use them in actual
code. You can do most of the \code{:} things in the code through other means,
but the \code{:} commands are limited to the interactive environment.

\pg{Back to Business}

If you saw up there, we had to type out every single instance of which we could
concieve. That's annoying. Let's figure out how to do this on our own. This will
be a good segue to introduce \term{comprehension notation}

\begin{plainfile}
Idris> :let bools = [True, False]
Idris> [(x, y) | x <- bools, y <- bools]
[(True, True),
 (True, False),
 (False, True),
 (False, False)] : List (Bool, Bool)
\end{plainfile}

Okay, what the hell is that? Let's go over this step-by-step

\begin{enumerate}
\item I made the list \code{[True, False]}, and bound it to the name
  \code{bools} using the \code{:let} command.
\item The next line is a \term{list comprehension}. Basically, it's a way of
  making a list of items that satisfy some conditions. The pipe in the middle is
  the key thing. The stuff to the right of the pipe is the conditions, and the
  stuff to the left is what each item looks like. Let's look at that comprehension again.

  \begin{plainfile}
[(x, y) | x <- bools, y <- bools]
  \end{plainfile}

  So, the stuff on the left says that each item will look something like
  \code{(x,y)}. \code{x} and \code{y} are each described on the right side of
  the pipe.

  We'll encounter the $\in$ operator a lot. Basically, when you have a set $A$,
  $x \in A$ means that ``$x$ is an element of $A$''. You should read the $\in$
  as a really crappy E, for ``element of''. \code{<-} is a silly way of trying
  to replicate a $\in$.

  So, on the right-hand side of the pipe, \code{x <- bools} just means
  ``\code{x} is an element of \code{bools}''. Ditto for \code{y}. Note that
  currently we are dealing with lists, which are slightly different than sets.

  So, we have a set of items that look like \code{(x,y)}, where \code{x} and
  \code{y} are both elements of \code{bools}. Indeed, that's the result:
  \begin{plainfile}
[(True, True),
 (True, False),
 (False, True),
 (False, False)] : List (Bool, Bool)
  \end{plainfile}
\end{enumerate}

Alright, so we've listed all pairs of booleans. This is kind of boring. Also,
pairs suck, and are hard to deal with.

We're going to make a \term{truth table}. Basically, we are going to have two
booleans, \code{a} and \code{b}. We are then going to show the result of \code{a
  \&\& b} and \code{a || b}.

We're going to have to move over to a file, call it \terminal{truthtable.idr}:

\begin{plainfile}
module Main

main : IO ()
main = return ()
\end{plainfile}

\code{main = return ()} just says that the function \code{main} does nothing. If
you compile and run this program, nothing interesting is going to happen.

Let's put our list of Booleans in:

\begin{plainfile}
bools : List Bool
bools = [True, False]
\end{plainfile}

It's important to periodically compile your program to make sure there aren't
any errors. Run \code{idris truthtable.idr} (don't include \code{-o
  truthtable}). \

\begin{plainfile}
% idris truthtable.idr
     ____    __     _                                          
    /  _/___/ /____(_)____                                     
    / // __  / ___/ / ___/     Version 0.9.16
  _/ // /_/ / /  / (__  )      http://www.idris-lang.org/      
 /___/\__,_/_/  /_/____/       Type :? for help               

Idris is free software with ABSOLUTELY NO WARRANTY.            
For details type :warranty.
*truthtable>   
\end{plainfile}

We've loaded the file \code{truthtable} into the interactive environment, and we
can examine it interactively.

\begin{plainfile}
*truthtable> bools
[True, False] : List Bool
\end{plainfile}

Cool!

If you've programmed in other languages, you're probably used to dealing mostly
with primitive types (integers, strings, booleans). In a language like Idris,
abstraction is lexically very cheap, and is thus encouraged. We're going to make
a new data type for our row:

\begin{plainfile}
record TruthRow : Bool -> Bool -> Bool -> Bool -> Type where
  MkRow : (a : Bool) -> (b : Bool) -> TruthTable a b (a && b) (a || b)
\end{plainfile}